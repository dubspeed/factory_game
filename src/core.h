#ifndef CORE_H
#define CORE_H
#include <iostream>
#include <optional>
#include <vector>
#include <nlohmann/json.hpp>
#include "autogenerated/resources.h"
#include "serialization.h"

using json = nlohmann::json;

namespace Fac {
    static constexpr int MAX_STACK_SIZE = 100;

    enum class ResourceQuality {
        Normal,
        Pure,
        Impure,
    };

    std::map<ResourceQuality, float> const resource_quality_multiplier = {
        {ResourceQuality::Normal, 1.0},
        {ResourceQuality::Pure, 2.0},
        {ResourceQuality::Impure, 0.5},
    };

    struct Recipe {
        struct Ingredient {
            Resource resource;
            int amount;
            NLOHMANN_DEFINE_TYPE_INTRUSIVE(Ingredient, resource, amount)
        };

        std::vector<Ingredient> inputs;
        std::vector<Ingredient> products;
        int processing_time_s;

        NLOHMANN_DEFINE_TYPE_INTRUSIVE(Recipe, inputs, products, processing_time_s)
    };

    inline int generate_id() {
        static int id = 0;
        return id++;
    }

    class GameWorldEntity {
    public:
        [[nodiscard]] virtual int getId() const = 0;

        virtual ~GameWorldEntity() = default;

        virtual void update(double dt) = 0;

        std::string name = "GameWorldEntity";
    };

    class IInputLink {
    public:
        virtual ~IInputLink() = default;

        virtual void reconnectLinks(std::function<std::shared_ptr<GameWorldEntity>(int)> const &getEntityById) = 0;
    };

    struct Stack final : GameWorldEntity {
        void clear() {
            _amount = 0;
            resource = std::nullopt;
        }

        bool isEmpty() const {
            return _amount == 0;
        }

        bool isFull() const { return _amount == _max_stack_size; }

        bool canAdd(int const amount, Resource const &r) const {
            return _amount + amount <= _max_stack_size && (resource == r || resource == std::nullopt);
        }

        bool removeOne() {
            return removeAmount(1);
        }

        int getAmount() const { return _amount; }

        Resource getResource() const {
            if (!resource.has_value()) {
                return Resource::None;
            }
            return resource.value();
        }

        void lockResource(Resource const &r) { resource = r; }

        bool removeAmount(int const amount) {
            if (_amount >= amount) {
                _amount -= amount;
                if (_amount == 0) {
                    clear();
                }
                return true;
            }
            return false;
        }

        bool addOne(Resource const &r) {
            return addAmount(1, r);
        }

        bool addAmount(int const amount, Resource const &r) {
            if (_amount == 0) {
                resource = r;
            }
            if (_amount + amount <= _max_stack_size && resource == r) {
                _amount += amount;
                return true;
            }
            return false;
        }

        void update(double dt) override {
        }

        int getId() const override { return _id; }

        void setMaxStackSize(int max_stack_size) { _max_stack_size = max_stack_size; }

        NLOHMANN_DEFINE_TYPE_INTRUSIVE(Stack, _id, _amount, resource, _max_stack_size)

    private:
        int _amount = 0;
        int _id = generate_id();
        std::optional<Resource> resource = std::nullopt;
        int _max_stack_size = MAX_STACK_SIZE;
    };


    // Base interface for anything that can provide a stack
    class IStackAccessor {
    public:
        virtual ~IStackAccessor() = default;

        [[nodiscard]] virtual std::shared_ptr<Stack> getStack(int slot) const = 0;
    };

    // Specific interface for output-capable components
    class IOutputProvider : public IStackAccessor {
    public:
        [[nodiscard]] virtual std::shared_ptr<Stack> getOutputStack(int slot) const = 0;
    };

    // Specific interface for input-capable components
    class IInputProvider : public IStackAccessor {
    public:
        [[nodiscard]] virtual std::shared_ptr<Stack> getInputStack(int slot) const = 0;

        // Connect this input to another component's output
        virtual void connectInput(int inputSlot,
                                  std::shared_ptr<GameWorldEntity> sourceEntity,
                                  int sourceOutputSlot) = 0;
    };


    class OutputStackProvider : public IOutputProvider {
    protected:
        std::vector<std::shared_ptr<Stack> > _output_stacks;

    public:
        explicit OutputStackProvider(int const nr_of_outputs) {
            _output_stacks.resize(nr_of_outputs);
            for (int i = 0; i < nr_of_outputs; i++) {
                _output_stacks[i] = std::make_shared<Stack>();
            }
        }

        [[nodiscard]] std::shared_ptr<Stack> getStack(int const slot) const override {
            return getOutputStack(slot);
        }

        [[nodiscard]] std::shared_ptr<Stack> getOutputStack(int const slot) const override {
            return _output_stacks.at(slot);
        }

        NLOHMANN_DEFINE_TYPE_INTRUSIVE(OutputStackProvider, _output_stacks)
    };

    struct InputConnection {
        std::weak_ptr<IOutputProvider> source;
        int sourceId = 0;
        int sourceOutputSlot = 0;
        std::shared_ptr<Stack> cachedStack;
    };


    class InputStackProvider : public IInputProvider, public IInputLink {
    protected:
        std::vector<InputConnection> _input_connections;

    public:
        explicit InputStackProvider(int nr_of_inputs) {
            _input_connections.resize(nr_of_inputs);
            for (int i = 0; i < nr_of_inputs; i++) {
                _input_connections[i].cachedStack = std::make_shared<Stack>();
            }
        }

        [[nodiscard]] std::shared_ptr<Stack> getStack(int const slot) const override {
            return getInputStack(slot);
        }

        // if the connection has a link, it returns the linked OutputStack, otherwise it returns the cached stack
        [[nodiscard]] std::shared_ptr<Stack> getInputStack(int const slot) const override {
            const auto &connection = _input_connections.at(slot);
            if (auto const source = connection.source.lock()) {
                return source->getOutputStack(connection.sourceOutputSlot);
            }
            return connection.cachedStack;
        }

        void connectInput(int inputSlot,
                          std::shared_ptr<GameWorldEntity> sourceEntity,
                          int sourceOutputSlot) override {
            auto &connection = _input_connections.at(inputSlot);
            if (auto const provider = std::dynamic_pointer_cast<IOutputProvider>(sourceEntity)) {
                connection.source = provider;
            } else {
                throw std::runtime_error("Cannot connect input to non-output provider");
            }
            connection.sourceId = sourceEntity->getId();
            connection.sourceOutputSlot = sourceOutputSlot;
            connection.cachedStack = nullptr;
        }

        void reconnectLinks(std::function<std::shared_ptr<GameWorldEntity>(int)> const &getEntityById) override {
            for (int inputSlot = 0; inputSlot < _input_connections.size(); inputSlot++) {
                auto const &connection = _input_connections.at(inputSlot);
                if (connection.cachedStack == nullptr && connection.sourceId != 0) {
                    connectInput(inputSlot, getEntityById(connection.sourceId), connection.sourceOutputSlot);
                    std::cout << "Reconnected input " << inputSlot << " to " << connection.sourceId << std::endl;
                }
            }
        }

        NLOHMANN_DEFINE_TYPE_INTRUSIVE(InputStackProvider, _input_connections)
    };

    // features an internal stack as a buffer
    // so it can link to a belt and provide a larger stack as outputConnection
    class BufferedConnection final : public InputStackProvider, public OutputStackProvider {
    public:
        explicit BufferedConnection(): InputStackProvider(1), OutputStackProvider(1) {
            _output_stacks[0]->setMaxStackSize(MAX_STACK_SIZE);
        }
        NLOHMANN_DEFINE_TYPE_INTRUSIVE(BufferedConnection, _input_connections, _output_stacks)
    };

    class ResourceNode final: public GameWorldEntity {
        friend void from_json(const json &j, ResourceNode &r);;

    public:
        ResourceNode() = default;

        void setResource(Resource const &r, ResourceQuality const quality) {
            _active_resource = r;
            _quality = quality;
        }

        void setResource(Resource const &r) {
            _active_resource = r;
        }

        void setResourceQuality(ResourceQuality const quality) {
            _quality = quality;
        }

        [[nodiscard]] Resource getResource() const { return _active_resource; }
        [[nodiscard]] ResourceQuality getQuality() const { return _quality; }

        void update(double dt) override {
        }

        int getId() const override { return _id; }

    private:
        int _id = generate_id();
        Resource _active_resource;
        ResourceQuality _quality;
    };


    // Resource extractions speeds are 30 / 60 / 120 for impure, normal, pure
    class Extractor final: public GameWorldEntity, public OutputStackProvider, public IInputLink {
        friend void to_json(json &j, const Extractor &r);

        friend void from_json(const json &j, Extractor &r);

    public:
        double extraction_progress = 0.0;
        bool extracting = false;

        Extractor(): OutputStackProvider(1) {
        };

        void setDefaultSpeed(int const speed) {
            _default_extraction_speed = speed;
            if (_res_node_id > -1)
                update_extraction_speed();
        }

        int getDefaultSpeed() const {
            return _default_extraction_speed;
        }

        void setResourceNode(std::shared_ptr<ResourceNode> const &depot) {
            _res_node = depot;
            _res_node_id = depot->getId();
            _output_stacks.at(0)->lockResource(_res_node->getResource());
            update_extraction_speed();
        }

        [[nodiscard]] std::shared_ptr<ResourceNode> getResourceNode() const { return _res_node; };

        void update(double dt) override;

        int getId() const override { return _id; }

        void reconnectLinks(std::function<std::shared_ptr<GameWorldEntity>(int)> const &getEntityById) override {
            if (_res_node_id > -1)
                setResourceNode(std::dynamic_pointer_cast<ResourceNode>(getEntityById(_res_node_id)));
        }

        float getOutputRpm() const {
            if (_res_node_id == -1) {
                return 0;
            }

            return _extraction_speed;
        }

    private:
        void update_extraction_speed() {
            _extraction_speed = _default_extraction_speed * resource_quality_multiplier.at(_res_node->getQuality());
        }

        int _id = generate_id();
        int _res_node_id = -1;
        std::shared_ptr<ResourceNode> _res_node;
        int _extraction_speed = 60;
        int _default_extraction_speed = 60;
    };


    /**
    * Machine
    * -------------
    */
    class Machine: public GameWorldEntity, public IInputProvider, public OutputStackProvider {
        friend void from_json(const json &, Machine &);

        friend void to_json(json &j, const Machine &r);

    public:
        std::vector<BufferedConnection> _input_connections;

        double processing_progress = 0.0;
        bool processing = false;

        explicit Machine(int const input_slots = 1, int const output_slots = 1): OutputStackProvider(output_slots) {
            _output_slots = output_slots;
            _input_slots = input_slots;
            _input_connections.resize(input_slots);
            for (int i = 0; i < _output_slots; i++) {
                _output_stacks[i]->setMaxStackSize(MAX_STACK_SIZE);
            }
        }

        void setRecipe(std::optional<Recipe> const &r);

        [[nodiscard]] std::optional<Recipe> getRecipe() const;

        int getInputRpm() const;

        int getOutputRpm() const;

        void update(double dt) override;

        int getId() const override { return _id; }

        bool canStartProduction() const;

        [[nodiscard]] std::shared_ptr<Stack> getStack(int const slot) const override {
            return getInputStack(slot);
        }

        // implement getInputStack, getOutputStack
        [[nodiscard]] std::shared_ptr<Stack> getInputStack(int const slot) const override {
            return _input_connections.at(slot).getOutputStack(0);
        }

        void connectInput(int const inputSlot,
                          std::shared_ptr<GameWorldEntity> sourceEntity,
                          int sourceOutputSlot) override {
            auto &connection = _input_connections.at(inputSlot);
            connection.connectInput(0, sourceEntity, sourceOutputSlot);
        }

        // // TODO better API needed here
        [[nodiscard]] std::shared_ptr<Stack> getFirstInput() const {
            return getInputStack(0);
        }

        [[nodiscard]] std::shared_ptr<Stack> getSecondInput() const {
            return getInputStack(1);
        }

    private:
        int _id = generate_id();
        std::optional<Recipe> _active_recipe;
        int _input_slots = 0;
        int _output_slots = 0;
    };


    /**
     * ItemMover
     * ---------
     * parent class for Belts, Mergers and Splitters
     */
    class ItemMover : public InputStackProvider, public OutputStackProvider,
                      public std::enable_shared_from_this<ItemMover> {
    public:
        int getItemsPerSecond() const { return _items_per_s; }
        void setItemsPerSecond(int const items_per_s) { _items_per_s = items_per_s; }

        bool getActive() const { return _active; }
        bool getJammed() const { return _jammed; }

        ItemMover(int const input_nodes, int const output_nodes,
                  int const items_per_s): InputStackProvider(input_nodes), OutputStackProvider(output_nodes),
                                          _items_per_s(items_per_s) {
            // All item movers have a max stack size of 1
            std::ranges::for_each(_output_stacks, [&](std::shared_ptr<Stack> &output_stack) {
                output_stack->setMaxStackSize(1);
            });
        }

        std::vector<Resource> _in_transit_stack;

        float getOutputRpm() const {
            return _items_per_s * 60;
        }

    protected:
        double _time_to_next_transfer = 0.0;
        int _items_per_s = 0;
        bool _active = false;
        bool _jammed = false;
    };


    class Belt : public GameWorldEntity, public ItemMover {
        friend void from_json(const json &j, Belt &r);

    public:
        Belt(int const items_per_s = 1): ItemMover(1, 1, items_per_s) {
        }

        void update(double dt) override;

        int getId() const override { return _id; }

    protected:
        int _id = generate_id();
    };


    // TODO maybe the splitter can be a belt with a special case
    // TODO also consider the merger, which is the opposite of the splitter
    // a splitter has one input and two or more outputs
    class Splitter : public GameWorldEntity, public ItemMover {
        friend void from_json(const json &j, Splitter &r);

    public:
        Splitter(): ItemMover(1, 2, 1) {
        }

        void update(double dt) override;

        int getId() const override { return _id; }

    private:
        int _id = generate_id();
        bool split_to_first_output = true;
    };


    class Merger : public GameWorldEntity, public ItemMover {
        friend void from_json(const json &j, Merger &r);

    public:
        Merger(): ItemMover(2, 1, 1) {
        }

        void update(double dt) override;

        int getId() const override { return _id; }

    private:
        int _id = generate_id();
        bool merge_from_first_input = true;
    };
}

#endif //CORE_H
